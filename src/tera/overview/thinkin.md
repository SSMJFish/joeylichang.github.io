1. master故障元数据恢复
2. 全局事务的设计 不够完整
3. LB策略
4. HDFS
5. kv 表格 CPU利用率
6. 负载均衡 概率，容量搬迁总是选举，并且较为频繁
7. hdfs 小文件
8. 与 BigTable 对比
   1. PB 级的数据，上千台机器上
   2. 有的需要高吞 吐量的批处理，有的则需要及时响应，快速返回数据给最终用户。
   3. 利用这个模型，客户可以动态控 制数据的分布和格式，用户也可以自己推测3底层存储数据的位置相关性4。
   4. 可以通过 BigTable 的模式参数来控制数据是存放在内存中、还是硬盘上。
   5. Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map5。
   6. 位置相关性
      1. 用户可以通过选择合适的行关键字，在数据访问时有效利 用数据的位置相关性，从而更好的利用这个特性。
   7. 访问控制、磁盘和内存的使用统计都是在列族层面进行的。
   8. 用户可以指定只保存最后 n 个版本的数据，或者只保存“足够新”的 版本的数据
      1. Tera 这部分逻辑在哪里？
   9. Chubby
      1. 类似 Tera 的ZK + MetaTable
      2. 存储的元数据也不一样，BigTable 的模式信息、存储访问控制列表 都是在 Chubby 内
      3. 元数据组织完全不一样，BigTable 是三级，Tera 是两级
      4. 在 METADATA 表中还存储了次级信息12，包括每个 Tablet 的事件日志（例如，什么时候一个服务器开始 为该 Tablet 提供服务）。这些信息有助于排查错误和性能分析。
   10. BigTable 可以动态的向集群中添加（或者删除）Tablet 服务器。
   11. 由于 BigTable 的客户程序不必通过 Master 服务器来获取 Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master 服 务器的负载是很轻的。
       1. Tera 是直接从 ZK 获取的吗？那部分ZK 会不会压力很大
   12. 节点的 加入离开也不一样
   13. BigTable Master 重启之后 同样会扫描所有的机器收集一次信息
   14. 元信息发生变化场景
       1. 建立了一个新表或者删除了一个旧表
       2. 两个 Tablet 被合并了
       3. 一个 Tablet 被分割成两个小的 Tablet
   15. 。为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。Tablet 的元数据包 含了组成这个 Tablet 的 SSTable 的列表，以及一系列的 Redo Point15，这些 Redo Point 指向可能含有该 Tablet 数据的已提交的日志记录
   16. 当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。
       1. Tera 进行校验的逻辑应该仔细看一下
   17. 局部性群组的作用
       1. 将通常不会一起访问的列族分割成不同的局部性群组可以提高读取操作的效率
       2. Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载 完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据 特别有用：在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。
   18. 压缩算法 比较高效
   19. 设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件，因此 一个实际的日志文件中混合了对多个 Tablet 修改的日志记录。
       1. 我们首先把日志按照关键字（table，row name，log sequence number）排序。 排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起，
       2. 为了并行排序，我们先将日志分割成 64MB 的段，之后在不同的 Tablet 服务器对段 进行并行排序。这个排序工作由 Master 服务器来协同处理，并且在一个 Tablet 服务器表明自己需要从 Commit 日志文件恢复 Tablet 时开始执行。
   20. 在向 GFS 中写 Commit 日志的时候可能会引起系统颠簸，原因是多种多样的（比如，写操作正在进行的 时候，一个 GFS 服务器宕机了；或者连接三个 GFS 副本所在的服务器的网络拥塞或者过载了）。为了确保在 GFS 负载高峰时修改操作还能顺利进行，每个 Tablet 服务器实际上有两个日志写入线程，每个线程都写自己 的日志文件，并且在任何时刻，只有一个线程是工作的。如果一个线程的在写入的时候效率很低，Tablet 服务 器就切换到另外一个线程，修改操作的日志记录就写入到这个线程对应的日志文件中。每个日志记录都有一 个序列号，因此，在恢复的时候，Tablet 服务器能够检测出并忽略掉那些由于线程切换而导致的重复的记录。
   21. BigTable 日志 批量提交，Tera 好像没有吧？
   22. memtable 我们对内存表采用 COW(Copy-on-write)机制，这样就允许读写操作并行执 行。
   23. 性能对比

