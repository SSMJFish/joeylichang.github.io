# RPC概述

## 背景
第一次接触的RPC应该算是本科阶段的tomcat，工作之后由于性能问题基本被所有公司舍弃，之后接触的多数RPC都是单线程异步 + 回调 或者 dispatcher + wokers模型，基本解决了C10K问题。后面接触过一些协程类的框架但是底层线程模型还是之前的变种，只是在用户接口上更加方便了，一度认为RPC的线程模型大体如此了。直到遇到了brpc以及后来遇到的seastar，才发现最新的RPC已经不满足在操作系统层面上的抽象了，更加充分的考虑现代计算机硬件架构，比如SMP、NUMA、cache line、mem fence等等，进而提升性能。

本文先比较概括的介绍了RPC的设计要素，针对常见的线程模型进行了总结（[基于brpc作者的文档](https://github.com/apache/incubator-brpc/blob/master/docs/cn/threading_overview.md)），线程模型对RPC的性能至关重要也是RPC选型的重要参考。

## RPC要素
从使用者的角度看RPC框架在设计上应该考虑以下几点：
1. 编程模型快速高效
	* 从RPC的使用者角度，编程模型有同步编程和异步编程两种，后者的编程、问题定位的复杂度显然高一些。
	* 注意：这里讨论的是编程模型并不是框架使用的线程模型，很多框架用同步编程的模型方便开发者使用，但是底层采用异步多线程模型，比如基于协程的RPC框架其实就是异步用户态多线程模型。
2. 支持多种数据交互协议
3. 高性能
	* RPC框架的性能保障主要考虑三点：网络、CPU、磁盘，每一个方向深入都是比较大的话题，后面会针对CPU（线程模型）进行详细的讨论。
	* 由于网络和磁盘的操作都是比较耗时的操作，比较常见的解决方式是异步处理，有的RPC框架还对线程进行了区分（网络线程、磁盘线程等）来提高性能，但也不尽然brpc考虑到cache局部性，并没有区分网络线程和worker（CPU线程）。
4. 高度可运维
	* RPC应该一共强大且高性能的内置服务，帮助开发者分析并定位线上问题，例如：mem profile、cpu profie、mutex profile、请求统计分析等等，强大的内置服务不仅仅帮助开发者定位问题更可以指导开发者更好的使用RPC发挥最大性能。


从RPC设计者的角度RPC框架应该具备以下要素：
* 易用的数据格式和接口
* 支持多种数据交互协议
* 支持多种网络连接管理
* 高效的线程模型
* 支持异步、同步机制
* 高效的请求超时机制（[brpc的超时设计分析](https://github.com/apache/incubator-brpc/blob/master/docs/cn/timer_keeping.md)）
* 具备命名服务、负载均衡、组合访问（下游服务）

## 线程模型
本部分主要是参考[brpc的作者对线程模型的分析](https://github.com/apache/incubator-brpc/blob/master/docs/cn/threading_overview.md)，在此基础上结合一些自己的理解。

* 连接独占线程或进程
	1. 一个连接对应一个线程或进程，典型的应用是tomcat web server，显然性能是比较差的，因此也引入了C10K问题。

* 单程Reactor
	1. epoll + 回调的方式，本质上将一个连续的处理逻辑根据阻塞情况分成若干段同epllo串联起来。
	2. 问题
		1. 切割的每一段处理逻辑耗时不可控，如果耗时较多会堵塞其他的请求。
		2. 由于是单线程不具备多核扩展能力。
	3. 一个典型的应用是Redis，由于其大部分操作都是内存操作耗时较小不会影响其他请求。
		1. 问题：Redis只是大部分的操作都是内存操作，但是在Aof、RDB落盘期间如果磁盘出现问题（故障或者与磁盘IO过高）就会影响后面的请求，产品线会即刻感受到延迟增高。
	
* 协程（N:1线程库）
	1. 协程是用户态的线程，所有的协程运行在一个系统线程内，当协程发生堵塞时进行切换（寄存器、栈、信号）。
	2. 在能力上与单线程Reactor等价（如果单线程Reactor编码足够精致——一旦堵塞立刻注册到Reactor不存在任何耗时的小分段）。
	3. 问题：不具备多核扩展能力。

* 多线程Reactor
	1. dispatcher + workers模型（也可能是多个dispatcher）。
	2. 由于cache一致性的原因，性能并没有随着core的增加而线性提升。
	3. 常见的多dispatcher模型是按网络、CPU、Disk将线程分类没类有多个线程。
	4. 问题：
		1. 很难保证一个用户请求被精致的切分为若干个分段去Reactor注册回调，往往是回调中包括若干个同步的耗时请求（尤其是多人协同开发），导致没有充分发挥其性能。
		2. 线程之间的同步多数是mutex + queue，这又很难保证性能（优先级队列可以适当缓解）。
		3. 多线程Reactor往往是异步编程，当挂起位置在代码较为隐蔽的位置时（循环、子函数等）代码极难维护（尤其是新人维护旧代码）。
		4. 多线程之间共享指针是比较常见的，但是内存一旦出现问题由于是异步编程定位又相对较难。

* M:N线程库（[bthread](https://github.com/apache/incubator-brpc/tree/master/src/bthread)）
	1. bthread是brpc底层使用的线程模型，也是brpc高性能的保证。
	2. bthread是一个用户态的线程，但他并不是协程，主要区别有几下几点：
		1. N个协程对应一个线程，M个bthread对应N个线程（M >= N）。
		2. 从开发者的使用上看，bthread更像是一套用户态的pthread（提供了bthread_create、bthread_mutex、bthread_cond等接口）。
		3. 一个pthread一个时刻只能运行一个bthread，当bthread堵塞时不会切换其他的bthread，但是当有pthread空闲时会“偷”其他pthread在排队的bthread执行。
		4. bthread不能替换pthread，因为他不是完备的系统线程，没有优先级、时间片抢占等，只是针对网络处理（供brpc）使用。
		5. bthread和pthread之间通过butex可以进行同步。
	7. 优点：brpc使用bthread充分的利用了cache局部性、实现了高并发（详细介绍见后续文章）。


