# C++11内存序

## 背景
brpc为了提高性能在很多关键代码中使用了[wait-free或者lock-free](https://en.wikipedia.org/wiki/Non-blocking_algorithm)技术，wait-free、lock-free技术通过去除锁完成多线程同步，因为锁的临界区比较大的话会影响程序性能。在C++11中引入了原子指令可以不用锁实现多线程间的同步，本文针对原子操作的六种内存序对原子指令进行讲解。

本文试图用比较简单易懂的语言描述清楚多线程同步遇到的问题、解决方法、以及C++11中std::atomic如何使用内存序实现多线程同步达到程序需要的正确结果并兼顾性能。本文并未涉及过多的学术用语，更没有从学术的角度描述多线程同步（相关内容可以在参考资料中查阅），本文主要目标还是实用，通过对原理的理解最终可以正确使用C++11中原子变量的内存序。

## 问题
### 指令重排
CPU/编译器都会对程序进行指令重排的优化，重排的结果是后面的指令可能被优化到前面去了，这样的做原因主要是提升性能，CPU、编译希望在一个时间片内尽量多的执行指令。这种优化对于单线程程序还不是致命的，但是对于多线程之间的同步可能是未定义的。如下代码，预期指令顺序是#1->#2->#3->#4，进过编译器和CPU指令重排后可能变为#2->#3->#4->#1，程序将core掉。

| threaA      | threadB           |      |
| ------------- | ------------------ | ---- |
| a = 1        |                         | #1 |
| flag= true |                         | #2 |
|                 | if flag== true    | #3 |
|                 | assert(a == 1)  | #4 |

### 内存屏障
为了解决指令重排带来的顺序问题，C++11提供了内存屏障，简单说内存屏障规定了在屏障之前的的指令不能重排到屏障之后，在屏障之后的指令不能重排到指令之前。C++11提供了六种内存序来实现不同类型的内存屏障。

## CacheLine
现代的CPU架构为了提升性能会设置多级cacheline作为CPU和内存之间的缓冲，缓解两者之间速度的差异。CacheLine常见的形式是分级缓存，每个CPU会有独享的指令和数据缓存，也有所有CPU共享的缓存。一个core读写数据之后会缓存在cacheline，另一个CPU的core此时读写同一块内存，需要确认这块数据在其他CPU的cacheline中的值，这个过程对程序透明，待一致性同步之后才能使用该数据。这个过程如果过于频繁就会影响程序的整体性能。

## 内存一致性模型
如上所述使用原子指令完成多线程同步具有乱序、性能可能不佳的问题。内存一致性模型像是协议一般的存在，开发者根据和CPU/编译器约定好的模型（协议）种类选择一种最适合程序需要的模型完成多线程同步。常见的内存一致性模型包括：

* 松弛型一致性：只保证其成员函数操作本身是原子不可分割的，但是对于顺序性不做任何保证。
* 顺序一致性：多线程行为相当于是这些操作都以一种特定顺序被一个线程执行，注意并不保证每次的执行结果都是一样的（线程内有序，线程间顺序不固定）。
* 释放-获取一致性：release之前的指令不会重排到当前指令之后，acquire之后的指令不能重排到当前指令之前。
	* 注意具备了多线程同步的语义在其中（后面看例子会易懂一些）。

## C++11内存序
针对上述三种内存一致性模型，C++11提供了六种内存序与之对应。

### 释放-获取一致性
**1. memory_order_release/memory_order_acquire**

memory_order_release用于store操作，memory_order_acquire用于load操作，两者必须配对使用。release操作可以阻止这个调用之前的读写操作被重排到后面去，而acquire操作则可以保证调用之后的读写操作不会重排到前面来。

| threaA                                                     | threadB                                                                |      |
| ---------------------------------------------------- | --------------------------------------------------------------- | --- |
| a = 1                                                        |                                                                            | #1 |
| flag.store(true, memory_order_release) |                                                                             | #2 |
|                                                                 | iif( true == flag.load(memory_order_acquire))    | #3 |
|                                                                 | assert(a == 1)                                                     | #4 |

#1不会重排到#2之后，#4不会重排到#3之前，保证了线程间的顺序，进而完成了线程间的同步。

**2. memory_order_release/memory_order_consume**

memory_order_release还可以和memory_order_consume搭配使用。memory_order_consume用于load操作，consume具备依赖关系，且依赖关系可传递，示例如下：

| threaA                                                     | threadB                                                                  |      |
| ---------------------------------------------------- | ----------------------------------------------------------------- | --- |
| b=true                                                      |                                                                               |     |
| a=1                                                          |                                                                               | #1 |
| flag.store(b, memory_order_release)      |                                                                               | #2 |
|                                                                 | while (!(c = flag.load(memory_order_consume)))  | #3 |
|                                                                 | assert(a==1)                                                          | #4 |
|                                                                 | assert(c==true)                                                      | #5 |
|                                                                 | assert(b==true)                                                      | #6 |

禁止重排的逻辑与release/acquire相同，区别在于只对具有依赖关系的变量不进行重排。flag依赖b，c依赖flag，所有#5#6是正确的，但是原子指令并没有依赖a，所有#4可能会失败，因为threadA中a=1可能被优化到#4后面。

**3. memory_order_acq_rel**

release和acquire的结合体，兼具两者的特性。用于“读取-修改-写回”这一类既有读取又有修改的操作，例如CAS操作。

| threaA                                                            | threadB                                                                                                                    |      |
| ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | --- |
| a=1                                                                 |                                                                                                                                  | #1 |
| flag.store(b, memory_order_release)            |                                                                                                                                   | #2 |
|                                                                        | b=true                                                                                                                       | #3 |
|                                                                        | c=2                                                                                                                            | #4 |
|                                                                        | while (!flag.compare_exchange_weak(b, false, memory_order_acq_rel)){b = true} | #5 |
|                                                                        | assert(a==1)                                                                                                              | #6 |
| if (true == flag.load(memory_order_acquire) |                                                                                                                                    | #7 |
| assert(c == 2)                                                |                                                                                                                                    | #8 |

#2#5组成release-acquire对，因此#6一定成立。#5#7组成release-acquire对，因此#8一定成立。

### 顺序一致性模型（memory_order_seq_cst）
std::atomic的默认内存序选项，相当于memory_order_acq_rel，性能是最差的。任何使用该选项的写操作都相当于release操作，任何读操作都相当于acquire操作，任何“读取-修改-写回”这一类的操作都相当于使用memory_order_acq_rel的操作。

### 松弛一致性模型（memory_order_relaxed）

## 注意
如果不是十分熟悉程序应用原子指令的场景乱用上述内存序性能可能比锁还差很多，这一点在[brpc文档](https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md)中有介绍。其次，多线程之间原子指令代码复杂度会高很多稍微不注意程序就会crash。在brpc中也不是所有的地方都是用了原子指令，还是有锁的。只在部分影响性能的代码里使用了，应谨慎使用原子指令进行同步。
